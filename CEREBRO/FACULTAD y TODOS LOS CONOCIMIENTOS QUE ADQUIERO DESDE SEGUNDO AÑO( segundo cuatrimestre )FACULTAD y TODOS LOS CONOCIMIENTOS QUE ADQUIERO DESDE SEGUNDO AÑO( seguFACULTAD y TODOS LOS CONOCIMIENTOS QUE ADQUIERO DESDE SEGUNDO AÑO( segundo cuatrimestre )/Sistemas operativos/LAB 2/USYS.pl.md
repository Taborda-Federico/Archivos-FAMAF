#!/usr/bin/perl -w

  

# Generate usys.S, the stubs for syscalls.

  

`print "# generated by usys.pl - do not edit\n";`

  

`print "#include \"kernel/syscall.h\"\n";`



`sub entry {`

	     `my $name = shift;`
		`print ".global $name\n";`

		`print "${name}:\n";`

		`print " li a7, SYS_${name}\n";`

		`print " ecall\n";`

`print " ret\n";`
`}`

`entry("fork");`
`entry("exit");`
`entry("wait");`
`entry("pipe");`
`entry("read");`
`entry("write");`
`entry("close");`
`entry("kill");`
`entry("exec");`
`entry("open");`
`entry("mknod");`
`entry("unlink");`
`entry("fstat");`
`entry("link");`
`entry("mkdir");`
`entry("chdir");`
`entry("dup");`
`entry("getpid");`
`entry("sbrk");`
`entry("sleep");` 
`entry("uptime");`

En la funcion entry pareciera como que se esta implementando la call que se le pasa

print " li a7, SYS_${name}" aca en SYS_{name} se esta complentado SYS_FORK por ejemplo,
osea que lo que pasa es que se completa SYS_ con el argumento que se le pase a entry. Luego SYS_FORK que esto? bueno vimos en [[kernel SYSCALL.H]] que temos constantes asosiadas a las macros como esta antes mencionada 

Ese valor se usa para hacer algo en las traps pero nose que todavi y el flujo sige [[usys.S]]

